---
title: Spying on My Classmates With an ESP8266
publishedAt: 2022-03-02T18:00:00Z
excerpt: I got sick of the crowded cafeteria at my school and tried to gain insight into when people go there.
---

The cafeteria in my school is often incredibly crowded. As I am a person who likes to eat while
sitting at a table and not standing, I set out to solve this problem. Although I felt that I had a
pretty good picture of when the peak hours were, I wanted to draw some accurate charts.

![](https://lh3.googleusercontent.com/BL8ZDqdxEpo4SHbZTzCk_BppFbNjcMR-qKqFUx8ua1B522GfghtU6R10TVWZxS9FbUA=w400)

My main source of inspiration was the "Popular times" section found in Google Maps. Google uses
anonymized location data from its users to determine where everyone is. I considered adopting this
strategy but quickly realized that my websites attract too little traffic for this kind of data collection.
I wasn't going to build a native app for just this purpose and then persuade hundreds of students to
install it.

Instead, I turned to wireless analysis. I had some [Raspberry Pi Zero W](https://www.raspberrypi.com/products/raspberry-pi-zero-w/)
single-board computers collecting dust in a drawer and figured that I could put them to better use.
I was going to sniff the network traffic in my school.

The Pi Zero W supports two wireless standards:

- Bluetooth 4.1 (and Low Energy)
- `802.11 b/g/n` WiFi

I experimented a bit with listening for nearby Bluetooth devices since I thought this would give me
a rough idea of how many people were nearby. I quickly ran into compilation complications trying to
cross-compile Rust for the `ARMv6` architecture (and dynamically linking some Bluetooth library) and
decided to give up on Rust and Bluetooth on the Pi.

As I tried to make my Rust program talk with the Bluetooth adapter on my Raspberry Pi, I
laid out deployment plans. I would try to hide the little computer somewhere in the cafeteria and
hope for the best. Eventually, I realized that the Pi (albeit not much larger than a flash drive) was
too big, at least with the wall adaptor and power cable included in the calculation. The device had
to be even smaller. It was time to **embed**.

Enter the [Espressif 8266 microcontroller](https://www.espressif.com/en/products/socs/esp8266).
Launched in August 2014, this chip is neither the newest nor the fastest. But it supports `802.11 b/g/n`
WiFi and can be found for less than a euro. Eager to get my hands dirty with embedded programming,
I built a flashing station on a breadboard and connected the FTDI programmer to my computer. The first
few hours were devoted to just making the chip blink with code.

## Software

After the microcontroller finally started to blink, I moved on to actually writing the software that
would be used in the wild. I had a rough idea of what I wanted the microcontroller to do:

1. Count the number of WiFi devices nearby.
2. Store the data somewhere.
3. Sleep for a few minutes, then `GOTO 1`.

Simple enough, I said to myself. Boy was I wrong ...

### 1. Counting Nearby WiFi Devices

I had screwed around with Wirehark and Aircrack-ng enough to know that you need a dedicated WiFi
interface for monitoring. In other words, you cannot be connected to a WiFi network and sniff
WiFi frames at the same time (unless you have more than one antenna, which almost all modern WiFi
devices do). The ESP8266 has a single 2.4&nbsp;GHz antenna.

"But why do you need to connect to a WiFi network in the first place?", you might ask. Well, I need to
do something with the data I collect. I could indeed store everything on an SD card and read from it once
in a week or so, but I wanted the data to be near real-time. Therefore, I needed to connect to some WiFi
network (more about that later) and call home with the newly acquired data once in a while.

Because I am a coward, I used the Arduino WiFi library instead of some lower-level SDK to program the
microcontroller.

```cpp filename=main.cpp
#include <ESP8266WiFi.h>

uint16_t packet_count = 0;

void handle_packet(uint8_t *buf, uint16_t len)
{
  packet_count++;
}

void sniffer_init()
{
  packet_count = 0;
  wifi_set_promiscuous_rx_cb(handle_packet);
  wifi_promiscuous_enable(1);
  wifi_set_channel(1);
}

// ...
```

### 2. Storing Activity Data

The data collected is useless unless it's read by someone. I did initially consider
building a custom time-series database from scratch, but calmed myself down when I
stumbled upon [InfluxDB](https://www.influxdata.com/). The core database is open source,
and they give you two free buckets with 30-day data retention. They offered exactly what
I needed.

I signed up for an account, and after a few hours, the microcontroller was sending
measurements to the database. I had anticipated the storage backend to be the biggest
pain to build and maintain, but was happily mistaken.

### 3. Sleeping

The microcontroller didn't need to sniff WiFi traffic or transmit data constantly, and performing that
many DHCP requests would probably make me hit a rate limit anyway. (If there's a neat way to avoid
the lengthy DHCP process every time I reconnect, do let me know!)

In between monitoring and connecting to the WiFi, the ESP8266 needs to do basically nothing. I had
previously heard of a feature called _deep sleep_ in which the microcontroller draws basically no
current (10 microamps which means 33 *micro*watts of power, in theory ...).

<table>
  <thead>
    <tr>
      <th>Mode</th>
      <th>Typical current</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Tx 802.11b</td>
      <td>170 mA</td>
      <td rowSpan="3">WiFi transmission</td>
    </tr>
    <tr>
      <td>Tx 802.11g</td>
      <td>140&nbsp;mA</td>
    </tr>
    <tr>
      <td>Tx 802.11n</td>
      <td>120&nbsp;mA</td>
    </tr>
    <tr>
      <td>Rx 802.11b</td>
      <td>50&nbsp;mA</td>
      <td rowSpan="3">WiFi receival</td>
    </tr>
    <tr>
      <td>Rx 802.11g</td>
      <td>56&nbsp;mA</td>
    </tr>
    <tr>
      <td>Rx 802.11n</td>
      <td>56&nbsp;mA</td>
    </tr>
    <tr>
      <td>Modem-sleep</td>
      <td>15&nbsp;mA</td>
      <td>WiFi off</td>
    </tr>
    <tr>
      <td>Light-sleep</td>
      <td>0.5&nbsp;mA</td>
      <td></td>
    </tr>
    <tr>
      <td>Deep-sleep</td>
      <td>10&nbsp;µA</td>
      <td></td>
    </tr>
    <tr>
      <td>Power off</td>
      <td>0.5&nbsp;µA</td>
      <td></td>
    </tr>
  </tbody>
</table>

I was puzzled when my microcontroller refused to sleep deeply (or rather, refused to wake up).
After some googling, though, I found out that the `RST` pin on the ESP has to be connected to
`GPIO16` in order to enable the internal timer to wake up the microcontroller after a certain
amount of time. The only caveat is, the variant that I own (the ESP8266**-01**) does _not_ come
with these pins connected out-of-the-box.

I discovered a well-written tutorial on
[how to solder the pins together](https://www.instructables.com/Enable-DeepSleep-on-an-ESP8266-01/),
but I didn't really feel like I was competent enough with the soldering iron.

Instead, I just called the built-in `delay` function after making sure to disable the WiFi
antennas with `WiFi.forceSleepBegin`. The power savings are negligible anyway when the ESP
is connected to the wall.

## Hardware

The microcontroller was flashed and ready to start monitoring, but I was yet to build the power
delivery circuitry that would convert 230 volts of alternating current into something that wouldn't
spawnkill the ESP8266.

I didn't want to screw around with high-voltage AC, so I just used an old USB power adapter to
get the sweet low-voltage direct current. Only problem is, USB is five volts, which is far too
much for the ESP8266 which ideally wants 3.3&nbsp;VDC. A number of people online claim that five
volts might fry the ESP8266, since it's quite finicky about what voltage it receives.

There are many ways to step five volts down to 3.3, but I won't (and can't) go into detail about
what method is the best. For this project, I used the _LD1117V33_ linear voltage regulator. The
schematics told be to include two capacitors in the circuit, and I did as the schematics told.
After some below-average solder jobs, the multimeter reported 3.3 volts.

The assembly went relatively smooth, except that I accidentaly ordered a stripboard instead of a
perfboard and had to file down some of the traces.

<Image src="/assets/esp.jpg" width={3000} height={4000} />

## Results

Reading the charts, there are very apparent peaks during school hours and especially lunch hours,
which is exactly what I was hoping to see. You can explore the data for yourself at
[sl.skolorna.com](https://sl.skolorna.com/).
